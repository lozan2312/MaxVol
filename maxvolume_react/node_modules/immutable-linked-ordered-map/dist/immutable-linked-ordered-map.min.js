/*! For license information please see immutable-linked-ordered-map.min.js.LICENSE.txt */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("ImmutableLinkedOrderedMap",[],t):"object"==typeof exports?exports.ImmutableLinkedOrderedMap=t():e.ImmutableLinkedOrderedMap=t()}(this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=4)}([function(e,t,r){"use strict";(function(e){r.d(t,"a",(function(){return n})),r.d(t,"e",(function(){return o})),r.d(t,"f",(function(){return s})),r.d(t,"b",(function(){return u})),r.d(t,"c",(function(){return a})),r.d(t,"k",(function(){return c})),r.d(t,"j",(function(){return l})),r.d(t,"i",(function(){return d})),r.d(t,"h",(function(){return p})),r.d(t,"g",(function(){return h})),r.d(t,"d",(function(){return f}));r(1);const n={uniqueIdPrefix:"",elementUniqueIdPrefix:"",checkNetworkURI:null};function o(e){for(const t in e)if(Object.prototype.hasOwnProperty.call(e,t))return!1;return!0}const i=Object.prototype.toString.call({}),s=e=>null!==e&&"object"==typeof e&&e.constructor===Object&&function(e){return i===Object.prototype.toString.call(e)}(e);function u(e){return Object.prototype.toString.call(e)===Object.prototype.toString.call([])}function a(e){return!e||0===e.length}function c(t){const r=void 0!==e?e:window;r.JSUtlUniqueIdCounterLEzKKl87QCDxwVH=r.JSUtlUniqueIdCounterLEzKKl87QCDxwVH||0,r.JSUtlUniqueIdCounterLEzKKl87QCDxwVH++;const o=r.JSUtlUniqueIdCounterLEzKKl87QCDxwVH;return(t||n.uniqueIdPrefix)+o}const l=(e,t,r)=>{let n=0,o=e;for(;n<t.length-1;){const e=t[n],r=o.get(e);if(r instanceof Map||r instanceof WeakMap)o=r;else{const t=new Map;o.set(e,t),o=t}n++}o.set(t[n],r)},d=(e,t)=>{let r=e,n=0;const o=t.length;for(;(r instanceof Map||r instanceof WeakMap)&&r.has(t[n])&&n<o;)r=r.get(t[n]),n++;return n==o};Symbol("treeMapSubtree");function*p(e,t,r){e.map();const n=t.bind(r);for(let t=0;t<e.length;t++)yield n(e[t],t,e)}function h(e){return void 0===e}function f(e){try{JSON.parse(e)}catch(e){return!1}return!0}}).call(this,r(3))},function(e,t,r){"use strict";r.d(t,"a",(function(){return i})),r.d(t,"b",(function(){return s}));const n=Object.prototype.hasOwnProperty;function o(e,t){return e===t?0!==e||1/e==1/t:e!=e&&t!=t}function i(e,t,r){return n.call(t,r)&&o(e[r],t[r])}function s(e,t){if(o(e,t))return!0;if("object"!=typeof e||null===e||"object"!=typeof t||null===t)return!1;const r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return!1;for(let n=0;n<r.length;n++){if(!i(e,t,r[n]))return!1}return!0}},function(e,t,r){"use strict";const n=/[|\\{}()[\]^$+*?.-]/g;e.exports=e=>{if("string"!=typeof e)throw new TypeError("Expected a string");return e.replace(n,"\\$&")}},function(e,t){var r;r=function(){return this}();try{r=r||new Function("return this")()}catch(e){"object"==typeof window&&(r=window)}e.exports=r},function(e,t,r){"use strict";r.r(t),r.d(t,"default",(function(){return ye})),r.d(t,"ImmutableLinkedOrderedMapMode",(function(){return te})),r.d(t,"lazyMap",(function(){return Me}));var n=r(0);!function(){let e=0}();const o=e=>Boolean("function"==typeof e?e():e);function i(e){return(()=>{let t=0;for(;t<e.length-1;t++){const r=e[t],[n,i]=r;if(o(n))return i}const r=e[t];if(Object(n.b)(r)&&2===r.length){const[e,t]=r;return o(e)?t:void 0}return r})()}const s=function*(e){const t=Reflect.ownKeys(e);for(const r of t){const t=e[r];yield{rule:r,pointcut:t}}},u=function*(e){for(const t of e)if(Object(n.b)(t)){const[e,r]=t;yield{rule:e,pointcut:r}}else yield*s(t)};class a{}class c extends a{constructor(e){super(),this.rules=e}matches(e){for(const t of this.rules)if(t.matches(e))return!0;return!1}}class l extends a{constructor(e){super(),this.regex=new RegExp(e)}matches(e){return this.regex.lastIndex=0,"symbol"!=typeof e&&this.regex.test(e)}}class d extends a{constructor(e){super(),this.property=e}matches(e){return this.property===e}}const p=e=>new l(e),h=e=>new d(e),f=e=>{let t=e;return i([[()=>e instanceof RegExp,p],[()=>{if("string"!=typeof e)return!1;const r=e.indexOf("/"),n=e.lastIndexOf("/");if(0===r&&n>0){const r=e.substring(1,n),o=e.substring(n+1)||void 0;return t=new RegExp(r,o),!0}return!1},p],h])(t)},m=e=>{const t=[];for(const r of e){const e=f(r);t.push(e)}return new c(t)};function x(e){return i([[Object(n.b)(e),m],f])(e)}class y{constructor(){var e,t,r;r=[],(t="advices")in(e=this)?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r}}class v{constructor(e){this.fn=e}}class g extends v{}class b extends v{}class O extends v{}class k extends y{before(e){return this.advices.push(new g(e)),this}after(e){return this.advices.push(new b(e)),this}around(e){return this.advices.push(new O(e)),this}}class A extends y{before(e){return this.advices.push(new g(e)),this}after(e){return this.advices.push(new b(e)),this}around(e){return this.advices.push(new O(e)),this}}class w extends y{before(e){return this.advices.push(new g(e)),this}after(e){return this.advices.push(new b(e)),this}around(e){return this.advices.push(new O(e)),this}}class M extends y{before(e){return this.advices.push(new g(e)),this}after(e){return this.advices.push(new b(e)),this}around(e){return this.advices.push(new O(e)),this}}class N extends y{before(e){return this.advices.push(new g(e)),this}after(e){return this.advices.push(new b(e)),this}around(e){return this.advices.push(new O(e)),this}}var C=Symbol("applyRule");var E=Symbol("constructRule");function P(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}const I=Symbol("noReturnValue");class D{constructor(){P(this,"execContextStack",[]),P(this,"execContextID",-1)}execute(e,t,r,n){this.newExecutionContext(),this.setUpExecutionContext(t,r),this.startExecutionContext(e),this.beforePhase(e,t),this.aroundPhase(e,r);const o=this.proceedPhase(e);return this.afterPhase(e,n,o),this.endExecutionContext(e),this.cleanUpExecutionContext(),o}newExecutionContext(){const e={proceeds:[],hasAtLeastOneAroundAdvice:!1,hasAtLeastOneBeforeAdvice:!1,returnValue:I};this.execContextStack.push(e),this.execContextID++}setUpExecutionContext(e,t){this.execContextStack[this.execContextID].hasAtLeastOneBeforeAdvice=!!e.length,this.execContextStack[this.execContextID].hasAtLeastOneAroundAdvice=!!t.length}startExecutionContext(e){}endExecutionContext(e){}cleanUpExecutionContext(){this.execContextStack.pop(),this.execContextID--}unsupportedMultipleProceeds(e,t){console.error("pigretto - Multiple proceeds for the same advice are not supported, subsequent proceed has been ignored.","\n\tadvice: ",e,"\n\trule: ",t)}executeBeforeAdvice(e,t,r){throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement "executeBeforeAdvice".`)}executeAroundAdvice(e,t,r,n){throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement "executeAroundAdvice".`)}executeAfterAdvice(e,t,r,n){throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement "executeAfterAdvice".`)}performUnderlyingOperation(e){throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement "performUnderlyingOperation".`)}executeProceedCallback(e,t,r,n){throw new Error(`pigretto - ${this.constructor.name} trap executor does not implement "executeProceedCallback".`)}beforePhase(e,t){for(const{rule:r,advice:n}of t)this.executeBefore(e,n,r)}executeBefore(e,t,r){this.executeBeforeAdvice(e,t,r)}aroundPhase(e,t){for(const{rule:r,advice:n}of t)if(this.executeAround(e,n,r),this.execContextStack[this.execContextID].returnValue!==I)break}executeAround(e,t,r){let o=!1;const i=this.executeAroundAdvice(e,t,r,(e,i)=>{if(o)return void this.unsupportedMultipleProceeds(t,r);o=!0;let s=void 0,u=void 0;Object(n.b)(e)?(s=e,u="function"==typeof i?i:void 0):"function"==typeof e&&(u=e),this.execContextStack[this.execContextID].proceeds.push({params:s,fn:u,rule:r})});o||(this.execContextStack[this.execContextID].returnValue=i)}afterPhase(e,t,r){for(const{rule:n,advice:o}of t)this.executeAfter(e,o,n,r)}executeAfter(e,t,r,n){this.executeAfterAdvice(e,t,r,n)}proceedPhase(e){if(this.execContextStack[this.execContextID].returnValue!==I)return this.return(e,this.execContextStack[this.execContextID].returnValue);let t=this.performUnderlyingOperation(e);for(const{fn:r,rule:n}of this.execContextStack[this.execContextID].proceeds)"function"==typeof r&&(t=this.executeProceedCallback(e,n,t,r));return this.return(e,t)}return(e,t){return t}}const L=(e,t,r)=>{if("function"!=typeof e[t])throw new Error(`pigretto - ${r.name} trap executor does not implement "${t}".`)};function j(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}const B=e=>{const t=class extends e{constructor(...e){super(...e),j(this,"executedAtLeastOnce",!1),j(this,"lastProceedWithParamsIndexMap",{}),j(this,"finalTrapArgsMap",{})}startExecutionContext(t){if(!this.executedAtLeastOnce&&L(e.prototype,"startExecutionContext",e),super.startExecutionContext(t),!this.executedAtLeastOnce&&!Object.prototype.hasOwnProperty.call(this,"execContextID"))throw new Error(`pigretto - ${e.name} trap executor does not have "execContextID" property.`);this.lastProceedWithParamsIndexMap[this.execContextID]=-1,this.finalTrapArgsMap[this.execContextID]=void 0}endExecutionContext(t){!this.executedAtLeastOnce&&L(e.prototype,"endExecutionContext",e),super.endExecutionContext(t),this.finalTrapArgsMap[this.execContextID]=void 0,this.executedAtLeastOnce=!0}getFinalTrapArgs(t){!this.executedAtLeastOnce&&L(this,"getTrapArgsArgumentsListIndex",e);const r=this.getTrapArgsArgumentsListIndex();if(!this.executedAtLeastOnce&&!Object.prototype.hasOwnProperty.call(this,"execContextStack"))throw new Error(`pigretto - ${e.name} trap executor does not have "execContextStack" property.`);const o=this.execContextStack[this.execContextID].proceeds.length;if(o){let e=!1;for(let i=o-1;i>this.lastProceedWithParamsIndexMap[this.execContextID];i--){const{params:o}=this.execContextStack[this.execContextID].proceeds[i];if(Object(n.b)(o)){e=!0,this.lastProceedWithParamsIndexMap[this.execContextID]=i,(t=[...t])[r]=o,this.finalTrapArgsMap[this.execContextID]=t;break}}e||(this.lastProceedWithParamsIndexMap[this.execContextID]=o-1)}return Object(n.g)(this.finalTrapArgsMap[this.execContextID])?t:this.finalTrapArgsMap[this.execContextID]}executeAroundAdvice(t,r,n,o){return t=this.getFinalTrapArgs(t),!this.executedAtLeastOnce&&L(e.prototype,"executeAroundAdvice",e),super.executeAroundAdvice(t,r,n,o)}executeAfterAdvice(t,r,n,o){t=this.getFinalTrapArgs(t),!this.executedAtLeastOnce&&L(e.prototype,"executeAfterAdvice",e),super.executeAfterAdvice(t,r,n,o)}performUnderlyingOperation(t){return t=this.getFinalTrapArgs(t),!this.executedAtLeastOnce&&L(e.prototype,"performUnderlyingOperation",e),super.performUnderlyingOperation(t)}executeProceedCallback(t,r,n,o){return t=this.getFinalTrapArgs(t),!this.executedAtLeastOnce&&L(e.prototype,"executeProceedCallback",e),super.executeProceedCallback(t,r,n,o)}};return Object.defineProperty(t,"name",{value:`WithFunctionTrapExecutor(${e.name})`,configurable:!0}),t};var S=B(class extends D{getTrapArgsArgumentsListIndex(){return 4}execute([e,t,r,o],i,s,u){if("function"==typeof o&&[i,s,u].some(e=>!Object(n.c)(e))){const n=e=>super.execute(e,i,s,u);return function(...i){let s;s=this!==r?this:e,o=o.bind(s);return n([e,t,r,o,i])}}return o}executeBeforeAdvice([e,t,r,,n],o,i){const s={target:e,property:t,receiver:r,rule:i};o.fn.apply(s,n)}executeAroundAdvice([e,t,r,,n],o,i,s){const u={target:e,property:t,receiver:r,rule:i};return o.fn.call(u,s).apply(u,n)}executeAfterAdvice([e,t,r,,n],o,i,s){const u={target:e,property:t,receiver:r,rule:i};o.fn.call(u,...n).apply(u,[s])}performUnderlyingOperation([,,,e,t]){return e(...t)}executeProceedCallback([e,t,r,,n],o,i,s){const u={target:e,property:t,receiver:r,rule:o,argumentsList:n};return s.apply(u,[i])}});function T(e,t,r){return Reflect.get(e,t,r)}class V extends D{executeBeforeAdvice([e,t,r],n,o){const i={target:e,property:t,receiver:r,rule:o};n.fn.apply(i)}executeAroundAdvice([e,t,r],n,o,i){const s={target:e,property:t,receiver:r,rule:o};return n.fn.apply(s,[i])}executeAfterAdvice([e,t,r],n,o,i){const s={target:e,property:t,receiver:r,rule:o};n.fn.apply(s,[i])}performUnderlyingOperation([e,t,r]){return T(e,t,r)}executeProceedCallback([e,t,r],n,o,i){const s={target:e,property:t,receiver:r,rule:n};return i.apply(s,[o])}}function U(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class F extends D{constructor(...e){super(...e),U(this,"previousPropertyValueMap",{}),U(this,"returnNewPropertyValueMap",{}),U(this,"updateWasSuccessfulMap",{})}startExecutionContext([e,t,,r]){if(!Object.prototype.hasOwnProperty.call(this.previousPropertyValueMap,this.execContextID)){const n=T(e,t,r);this.previousPropertyValueMap[this.execContextID]=n,this.returnNewPropertyValueMap[this.execContextID]=void 0,this.updateWasSuccessfulMap[this.execContextID]=!1}}endExecutionContext([,,,]){delete this.previousPropertyValueMap[this.execContextID],delete this.returnNewPropertyValueMap[this.execContextID],delete this.updateWasSuccessfulMap[this.execContextID]}executeBeforeAdvice([e,t,r,n],o,i){const s=this.previousPropertyValueMap[this.execContextID],u={target:e,property:t,value:r,receiver:n,rule:i};o.fn.apply(u,[s])}executeAroundAdvice([e,t,r,n],o,i,s){const u=this.previousPropertyValueMap[this.execContextID],a={target:e,property:t,value:r,receiver:n,rule:i};return o.fn.call(a,s).apply(a,[u])}executeAfterAdvice([e,t,r,n],o,i,s){const u=this.previousPropertyValueMap[this.execContextID],a=this.returnNewPropertyValueMap[this.execContextID],c={target:e,property:t,value:r,receiver:n,rule:i,updateWasSuccessful:s};o.fn.call(c,u).apply(c,[a])}performUnderlyingOperation([e,t,r,n]){const o=function(e,t,r,n){return Reflect.set(e,t,r,n)}(e,t,r,n);return this.updateWasSuccessfulMap[this.execContextID]=o,this.returnNewPropertyValueMap[this.execContextID]=r,r}executeProceedCallback([e,t,r,n],o,i,s){const u={target:e,property:t,value:r,receiver:n,rule:o};return s.apply(u,[i])}return([e,t,,r],n){return n!==this.returnNewPropertyValueMap[this.execContextID]&&this.performUnderlyingOperation([e,t,n,r]),this.updateWasSuccessfulMap[this.execContextID]}}var H=B(class extends D{getTrapArgsArgumentsListIndex(){return 2}executeBeforeAdvice([e,t,r],n,o){const i={target:e,thisArg:t,rule:o};n.fn.apply(i,r)}executeAroundAdvice([e,t,r],n,o,i){const s={target:e,thisArg:t,rule:o};return n.fn.call(s,i).apply(s,r)}executeAfterAdvice([e,t,r],n,o,i){const s={target:e,thisArg:t,rule:o};n.fn.call(s,...r).apply(s,[i])}performUnderlyingOperation([e,t,r]){return function(e,t,r){return Reflect.apply(e,t,r)}(e,t,r)}executeProceedCallback([e,t,r],n,o,i){const s={target:e,thisArg:t,rule:n,argumentsList:r};return i.apply(s,[o])}});var W=B(class extends D{getTrapArgsArgumentsListIndex(){return 1}executeBeforeAdvice([e,t,r],n,o){const i={target:e,newTarget:r,rule:o};n.fn.apply(i,t)}executeAroundAdvice([e,t,r],n,o,i){const s={target:e,newTarget:r,rule:o};return n.fn.call(s,i).apply(s,t)}executeAfterAdvice([e,t,r],n,o,i){const s={target:e,newTarget:r,rule:o};n.fn.call(s,...t).apply(s,[i])}performUnderlyingOperation([e,t,r]){return function(e,t,r){return r?Reflect.construct(e,t,r):new e(...t)}(e,t,r)}executeProceedCallback([e,t,r],n,o,i){const s={target:e,newTarget:r,rule:n,argumentsList:t};return i.apply(s,[o])}});function K(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class ${constructor(){K(this,"advices",{call:[],get:[],set:[],apply:[],construct:[]}),K(this,"distributedAdvices",{call:{before:void 0,around:void 0,after:void 0},get:{before:void 0,around:void 0,after:void 0},set:{before:void 0,around:void 0,after:void 0},apply:{before:void 0,around:void 0,after:void 0},construct:{before:void 0,around:void 0,after:void 0}}),K(this,"matchedDistributedAdvices",{call:new Map,get:new Map,set:new Map}),K(this,"trapExecutors",{call:new S,get:new V,set:new F,apply:new H,construct:new W})}hasAtLeastOneAdviceOfPointcutType(e){return!!this.advices[e].length}addAdvices(e,t,r=[]){r.map(r=>this.advices[e].push({rule:t,advice:r}))}lazilyDistributeAdvices(e){if(Object(n.g)(this.distributedAdvices[e].before)){this.distributedAdvices[e].before=[],this.distributedAdvices[e].around=[],this.distributedAdvices[e].after=[];for(const{rule:t,advice:r}of this.advices[e]){const n=i([[()=>r instanceof g,"before"],[()=>r instanceof O,"around"],"after"]);this.distributedAdvices[e][n].push({rule:t,advice:r})}}}lazilyMatchAdvices(e,t){this.lazilyDistributeAdvices(e);const r=this.matchedDistributedAdvices[e];if(!r.has(t)){const n={before:[],around:[],after:[]};r.set(t,n);const o=this.distributedAdvices[e].before,i=this.distributedAdvices[e].around,s=this.distributedAdvices[e].after,u=e=>r=>{for(const{rule:o,advice:i}of e){o.matches(t)&&n[r].push({rule:o,advice:i})}};u(o)("before"),u(i)("around"),u(s)("after")}}addPointcutRule(e,t){const r=()=>"function"==typeof e&&t instanceof d,n=i([[()=>e instanceof k,"call"],[()=>e instanceof A,"get"],[()=>e instanceof w,"set"],[()=>{const n=r()&&t.property===C;return!!(n||e instanceof M)&&(n&&(e=(new M).before(e)),!0)},"apply"],[()=>{const n=r()&&t.property===E;return!!(n||e instanceof N)&&(n&&(e=(new N).before(e)),!0)},"construct"]]);if(n){const{advices:r}=e;this.addAdvices(n,t,r)}return this}hasGets(){return this.hasAtLeastOneAdviceOfPointcutType("call")||this.hasAtLeastOneAdviceOfPointcutType("get")}hasSets(){return this.hasAtLeastOneAdviceOfPointcutType("set")}hasApplies(){return this.hasAtLeastOneAdviceOfPointcutType("apply")}hasConstructs(){return this.hasAtLeastOneAdviceOfPointcutType("construct")}get(e,t,r){this.lazilyMatchAdvices("get",t),this.lazilyMatchAdvices("call",t);const{before:n,around:o,after:i}=this.matchedDistributedAdvices.get.get(t),s=this.trapExecutors.get.execute([e,t,r],n,o,i),{before:u,around:a,after:c}=this.matchedDistributedAdvices.call.get(t);return this.trapExecutors.call.execute([e,t,r,s],u,a,c)}set(e,t,r,n){this.lazilyMatchAdvices("set",t);const{before:o,around:i,after:s}=this.matchedDistributedAdvices.set.get(t);return this.trapExecutors.set.execute([e,t,r,n],o,i,s)}apply(e,t,r){this.lazilyDistributeAdvices("apply");const{before:n,around:o,after:i}=this.distributedAdvices.apply;return this.trapExecutors.apply.execute([e,t,r],n,o,i)}construct(e,t,r){this.lazilyDistributeAdvices("construct");const{before:n,around:o,after:i}=this.distributedAdvices.construct;return this.trapExecutors.construct.execute([e,t,r],n,o,i)}}function R(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function z(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?R(Object(r),!0).forEach((function(t){q(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):R(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function q(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function G(e){const t=new $,r=function*(e){const t=i([[Object(n.b)(e),u],s]);yield*t(e)}(e);for(const{rule:e,pointcut:n}of r){const r=x(e);t.addPointcutRule(n,r)}return z(z(z(z({},t.hasGets()?{get:(e,r,n)=>t.get(e,r,n)}:{}),t.hasSets()?{set:(e,r,n,o)=>t.set(e,r,n,o)}:{}),t.hasApplies()?{apply:(e,r,n)=>t.apply(e,r,n)}:{}),t.hasConstructs()?{construct:(e,r,n)=>t.construct(e,r,n)}:{})}function Q(e,t){const r=function(e){return G(e)}(t);return new Proxy(e,r)}function _(){return new k}function J(){return new w}function Y(){return new A}var X=r(2),Z=r.n(X);const ee="ImmutableLinkedOrderedMapEWoFkvQyQsM32wK4a5Kd",te={SINGLE:1,MULTIWAY:2,LIGHTWEIGHT:3},re=te.MULTIWAY;function ne({initialItems:e=[],keyPropName:t="id",mode:r=re,lazy:n=!1}={}){let o=oe(r=Ae[r]&&r||(r=re));return ue.call(o,{keyPropName:t,mode:r}),n?o=function(e,t=[]){e.length=t.length;return function(e,{onceCallback:t,ignoredTypes:r=[Object],interceptConstructor:n=!1,propertiesToIgnore:o=[],pointcuts:i=[_,Y,J]}={}){let s=!1,u=!1,a=!1;const c=[],l={},d=r.map(e=>e.prototype.constructor);let p=e,h=!1;for(;p;){const t=p.constructor;if(!h||!d.includes(t)){Reflect.ownKeys(p).map(t=>l[t]={isMethod:"constructor"!==t&&"function"==typeof e[t]})}p=Object.getPrototypeOf(p),h=!0}o.map(e=>delete l[e]),!n&&delete l.constructor,i.map(e=>{e===_?s=!0:e===Y?u=!0:e===J&&(a=!0)});const f=Object.keys(l);let m=!0;const x=function(...e){m&&(m=!1,t.apply(this,e))},y=e=>e.map(Z.a),v=e=>new RegExp(`^(${e.join("|")})$`),g=e=>t=>c.push([e,t().before(x)]);if(s){g(v(y(f.filter(e=>l[e].isMethod))))(_)}if(u||a){const e=y(f.filter(e=>!l[e].isMethod));u&&g(v(e))(Y),a&&g(v(e))(J)}return Q(e,c)}(e,{onceCallback:()=>{e.length=0,le(e,t)}})}(o,e):le(o,e),o}function oe(e){return new(0,Ae[e].ImmutableLinkedOrderedMapClass)}function ie(e,t,r,n){const o={};o[t]={get:r,set:n},Object.defineProperties(e,o)}function se(e,t,r){return{previous:e,next:t,element:r}}function ue({keyPropName:e,mode:t}){ae.call(this,{heapMap:{},depth:0,length:0,keyPropName:e,mode:t});const r=Ae[t].hydrate;r&&r.call(this)}function ae({heapMap:e,depth:t,length:r,keyPropName:n,mode:o,head:i,tail:s,ancestorMap:u}={}){ie(this,"heapMap",()=>e),this.depth=t||0,this.length=r||0,this.keyPropName=n,ie(this,"mode",()=>o),this.head=i||null,this.tail=s||null,this.ancestorMap=u||null,this.shouldNextForEachBreak=!1,this.forEachNextFn=void 0,this.change=null,this[ee]=!0}function ce(e){return e&&!function(e){return e.isOrphanNode}(e)?e:void 0}function le(e,t=[]){const{mode:r,keyPropName:n}=e,o={},i=t.length;if(i){const s=t[i-1],{key:u,value:a}=de(n,s),c=Ae[r].makeImmutableLinkedOrderedMapNode(e,null,null,u,a);Ae[r].updateHeapMap(e,c);const l=e.tail;if(e.tail=c,o[u]||e.length++&&(o[u]=!0),i>1){let s=e.tail;for(let u=i-2;u>=0;u--){const i=t[u],{key:a,value:c}=de(n,i);if(!o[a]){const t=Ae[r].makeImmutableLinkedOrderedMapNode(e,null,null,a,c);Ae[r].updateHeapMap(e,t),Ae[r].bindNodes(e,t,s),s=t,e.length++&&(o[a]=!0)}}null===e.head&&(e.head=s)}else null===l?e.head=c:Ae[r].bindNodes(e,l,e.tail)}}function de(e,t){let r,n;if(t)if(r=t[e],void 0!==r)n=t;else{for(const e in t){r=e;break}n=t[r]}return{key:r,value:n}}function pe(e,t,r=!0){e.change={[t]:r}}let he=!1;function fe(e){he=!0;const t=oe(e.mode);he=!1,ae.call(t,{heapMap:e.heapMap,depth:e.depth,length:e.length,keyPropName:e.keyPropName,mode:e.mode,head:e.head,tail:e.tail,ancestorMap:e}),t.depth++;const r=Ae[e.mode].fork;return r&&r(e,t),t}function me(e,t){const r=Ae[e.mode].makeImmutableLinkedOrderedMapNode(e,null,null,t,void 0);r.isOrphanNode=!0,Ae[e.mode].updateHeapMap(e,r)}let xe=!1;class ye{constructor(e){if(!he){if(xe)return xe=!1,this;xe=!0;return ne(e)}}get[Symbol.toStringTag](){return this.constructor.name}set(e,t=!1){const r=Array.isArray(e);if(r&&!e.length||!e)return this;let n;r||(e=[e]);let o=!1;const i=[],s=[],u={};let a=e.length-1;let c,l,d,p;const h=({map:e,newNode:t,newNext:r})=>{Ae[e.mode].bindNodes(e,t,r)};if(p=()=>{},t)c=(e,t)=>{const r=e.head;return e.head=t,{newNext:r}};else{let e=!0;c=(t,r)=>{let n;return e?(e=!1,null!==t.tail&&(l=t.tail),t.tail=r,n=!1):n={newNext:d},d=r,n},p=()=>{d&&(null===n.head&&(n.head=d),l&&Ae[n.mode].bindNodes(n,l,d))}}for(;a>=0;a--){const r=e[a],{key:d,value:p}=de(this.keyPropName,r);if(u[d])continue;u[d]=!0;const f=Ae[this.mode].lookup(this,d);if(f){if(f.element.value!==p){n=n&&(o=!1)||n||(o=!0)&&fe(this);const e=!o&&Ae[n.mode].findMapNodeByDirection(n,f,"previous")||Ae[n.mode].findMapNodeByDirection(this,f,"previous"),t=!o&&Ae[n.mode].findMapNodeByDirection(n,f,"next")||Ae[n.mode].findMapNodeByDirection(this,f,"next"),r=Ae[n.mode].makeImmutableLinkedOrderedMapNode(n,null,null,d,p);Ae[this.mode].updateHeapMap(n,r),null!==e?Ae[n.mode].bindNodes(n,e,r):n.head=r,null!==t?Ae[n.mode].bindNodes(n,r,t):l?l=r:n.tail=r,s.unshift({key:d,value:p})}}else{n=n&&((o=!1)||n)||(o=!0)&&fe(this);const e=Ae[n.mode].makeImmutableLinkedOrderedMapNode(n,null,null,d,p);if(Ae[n.mode].updateHeapMap(n,e),null===n.tail&&t)n.tail=e,n.head=e;else{const t=c(n,e);if(t){const{newNext:r}=t;h({map:n,newNode:e,newNext:r})}}n.length++,i.unshift({key:d,value:p})}}return p(),n?(pe(n,"set",{inserted:i,updated:s,prependMissing:t}),n):this}replace(e,t,r=!1,n=!1){const o=Ae[this.mode].lookup(this,e);let i,s,u,a=!1,c=!1,l=!1;if(o){const r=de(this.keyPropName,t);if(s=r.key,u=r.value,o.element.value!==u){i=i||fe(this);const t=Ae[i.mode].makeImmutableLinkedOrderedMapNode(i,null,null,s,u),r=Ae[this.mode].findMapNodeByDirection(this,o,"previous"),n=Ae[this.mode].findMapNodeByDirection(this,o,"next");if(e+""!=s+""){me(i,e);const a=Ae[this.mode].lookup(this,s);if(a){if(l=!0,a.element.value!==u){a===i.head&&(i.head=t),a===i.tail&&(i.tail=t);const e=Ae[this.mode].findMapNodeByDirection(this,a,"previous"),s=Ae[this.mode].findMapNodeByDirection(this,a,"next");null!==e&&(o!==e?Ae[i.mode].bindNodes(i,e,t):null!==r?Ae[i.mode].bindNodes(i,r,t):i.head=t),null!==s&&(o!==s?Ae[i.mode].bindNodes(i,t,s):null!==n?Ae[i.mode].bindNodes(i,t,n):i.tail=t)}i.length--}}l||(null===r?(i.head=t,null===n?i.tail=t:Ae[i.mode].bindNodes(i,t,n)):null===n?(i.tail=t,Ae[i.mode].bindNodes(i,r,t)):(Ae[i.mode].bindNodes(i,r,t),Ae[i.mode].bindNodes(i,t,n))),Ae[i.mode].updateHeapMap(i,t),c=!0}}else if(r){i=i||fe(this);const e=Ae[this.mode].lookup(this,s),r=de(i.keyPropName,t);s=r.key,u=r.value;const o=Ae[i.mode].makeImmutableLinkedOrderedMapNode(i,null,null,s,u);if(Ae[i.mode].updateHeapMap(i,o),e&&(l=!0,e.element.value!==u)){e===i.head&&(i.head=o),e===i.tail&&(i.tail=o);const t=Ae[this.mode].findMapNodeByDirection(this,e,"previous"),r=Ae[this.mode].findMapNodeByDirection(this,e,"next");null!==t&&Ae[i.mode].bindNodes(i,t,o),null!==r&&Ae[i.mode].bindNodes(i,o,r),c=!0}if(!l)if(i.length++,a=!0,n){const e=i.head;i.head=o,null===e?i.tail=i.head:Ae[i.mode].bindNodes(i,o,e)}else{const e=i.tail;i.tail=o,null===e?i.head=i.tail:Ae[i.mode].bindNodes(i,e,o)}}return i?(pe(i,"replace",{oldKey:e,key:s,value:u,wasInserted:a,wasUpdated:c,hadExistentNodeForKey:l,prependMissing:n}),i):this}unset(e){const t=typeof e;if("number"===t||"string"===t)return this.unsetKey(e);const r=this.keyPropName;if(Array.isArray(e)){let t=this;for(const n of e)t=t.unsetKey(n[r]);return t}return this.unsetKey(e[r])}unsetKey(e){const t=Ae[this.mode].lookup(this,e);let r,n;if(t){r=r||fe(this),n=t.element.value,me(r,e);const o=Ae[r.mode].findMapNodeByDirection(this,t,"previous"),i=Ae[r.mode].findMapNodeByDirection(this,t,"next");if(null===o)if(null===i)r.head=null,r.tail=null,r.length=0;else{const e=Ae[r.mode].makeImmutableLinkedOrderedMapNode(r,null,null,i.element.key,i.element.value);Ae[r.mode].updateHeapMap(r,e),r.head=e;const t=Ae[r.mode].findMapNodeByDirection(this,i,"next");null===t?r.tail=e:Ae[r.mode].bindNodes(r,e,t),r.length--}else if(null===i){const e=Ae[r.mode].makeImmutableLinkedOrderedMapNode(r,null,null,o.element.key,o.element.value);Ae[r.mode].updateHeapMap(r,e),r.tail=e;const t=Ae[r.mode].findMapNodeByDirection(this,o,"previous");null===t?r.head=e:Ae[r.mode].bindNodes(r,t,e),r.length--}else Ae[r.mode].bindNodes(r,o,i),r.length--}return r?(pe(r,"unset",{key:e,value:n}),r):this}empty(){if(this.length<=0)return this;const e=new ye({initialItems:[],keyPropName:this.keyPropName,mode:this.mode});return e.length=0,e.depth=this.depth+1,e.ancestorMap=this,pe(e,"empty"),e}get(e){const t=Ae[this.mode].lookup(this,e);if(t)return t.element.value}first(){return this.head?{key:this.head.element.key,value:this.head.element.value}:void 0}last(){return this.tail?{key:this.tail.element.key,value:this.tail.element.value}:void 0}rangeBefore(e,t=1/0,r=!0){const n=Ae[this.mode].lookup(this,e);if(!n||t<=0)return[];let o=r?n:Ae[this.mode].findMapNodeByDirection(this,n,"previous");if(!o)return[];const i=[{key:o.element.key,value:o.element.value}];for(;o&&i.length<t&&(o=Ae[this.mode].findMapNodeByDirection(this,o,"previous"),o);)i.push({key:o.element.key,value:o.element.value});return i.reverse()}rangeAfter(e,t=1/0,r=!0){const n=Ae[this.mode].lookup(this,e);if(!n||t<=0)return[];let o=r?n:Ae[this.mode].findMapNodeByDirection(this,n,"next");if(!o)return[];const i=[{key:o.element.key,value:o.element.value}];for(;o&&i.length<t&&(o=Ae[this.mode].findMapNodeByDirection(this,o,"next"),o);)i.push({key:o.element.key,value:o.element.value});return i}isEmpty(){return this.length<=0}forEach(e,t=!1){let r,n,o,i,s,u;for(this.shouldNextForEachBreak=!1,this.forEachNextFn=void 0,t?(o=this.tail,i="previous",s=this.length-1,u=()=>s--):(o=this.head,i="next",s=0,u=()=>s++);o&&!this.shouldNextForEachBreak;){const t=o.element;r=t.key,n=t.value;if(!1===(this.forEachNextFn||e).call(this,n,r,s))break;o=Ae[this.mode].findMapNodeByDirection(this,o,i),u()}}break(){this.shouldNextForEachBreak=!0}values(e=!1){const t=new Array(this.length);let r=0;return this.forEach((function(e){t[r]=e,r++}),e),t}keys(e=!1){const t=new Array(this.length);let r=0;return this.forEach((function(e,n){t[r]=n,r++}),e),t}keysValues(e=!1){const t=new Array(this.length);let r=0;return this.forEach((e,n)=>{t[r]={key:n,value:e},r++},e),t}map(e,t=!1){const r=new Array(this.length);let n=0;return this.forEach((t,o,i)=>{r[n]=e(t,o,i),n++},t),r}reduce(e,t,r=!1){let n,o=!1;if(arguments.length>1)n=t;else{if(!this.length)throw new TypeError("ImmutableLinkedOrderedMap type error: Reduce of empty map with no initial value");o=!0,n=(r?this.last():this.first()).value}const i=(t,r,o)=>{n=e(n,t,r,o)};return this.forEach((function(e,t,r){this.forEachNextFn=i,o||i(e,t,r)}),r),n}filter(e,t=!1){const r=[];let n=0;return this.forEach((t,o,i)=>{e(t,o,i)&&(r[n]=t,n++)},t),r}every(e,t=!1){let r=!0;return this.forEach((t,n,o)=>{if(!e(t,n,o))return r=!1,!1},t),r}some(e,t=!1){let r=!1;return this.forEach((t,n,o)=>{if(e(t,n,o))return r=!0,!1},t),r}}function ve(e){throw new Error(`ImmutableLinkedOrderedMap error: Mutation operation "${e}" is not allowed on a map in single mode on which a mutation operation already occurred once.`)}function ge(e,t){return t.substring(0,e.length)===e}function be(e){throw new Error(`ImmutableLinkedOrderedMap error: Operation "${e}" is not allowed on a map in lightweight mode on which a mutation operation occurred once.`)}function Oe(){this.map={},this.keyValueList=new ke,this.shouldNextForEachBreak=!1}function ke(){this.head=null,this.tail=null,this.length=0,this.shouldNextForEachBreak=!1}Oe.prototype.set=function(e,t,r=!1){if(e in this.map)this.map[e].element.value=t;else{const n=r?"prepend":"append",o=this.keyValueList[n]({key:e,value:t});this.map[e]=o}},Oe.prototype.remove=function(e){if(!(e in this.map))throw new Error("key does not exist");this.keyValueList.remove(this.map[e]),delete this.map[e]},Oe.prototype.empty=function(){this.map={},this.keyValueList=new ke,this.shouldNextForEachBreak=!1},Oe.prototype.isEmpty=function(){return this.getLength()<=0},Oe.prototype.get=function(e,t=!1){return this.map[e]&&(t?this.map[e]:this.map[e].element.value)},Oe.prototype.forEach=function(e,t=!1){let r,n;this.shouldNextForEachBreak=!1;const o=this;this.keyValueList.forEach((function(t,i){if(this.shouldNextForEachBreak)return!1;r=i.key,n=i.value;if(!1===e.call(o,r,n))return!1}),t)},Oe.prototype.break=function(){this.shouldNextForEachBreak=!0},Oe.prototype.getLength=function(){return this.keyValueList.length},Oe.prototype.toArray=function(){const e=new Array(this.getLength());let t=0;return this.forEach((function(r,n){e[t]=n,t++})),e},Oe.prototype.keys=function(){const e=new Array(this.getLength());let t=0;return this.forEach((function(r){e[t]=r,t++})),e},Oe.fromArray=function(e,t){const r=new Oe;for(let n=0;n<e.length;n++){const o=e[n];r.set(o[t],o)}return r},ke.prototype.append=function(e){if(this.length++,this.head){const t=this.tail;this.tail=se(t,null,e),t.next=this.tail}else this.tail=se(null,null,e),this.head=this.tail;return this.tail},ke.prototype.prepend=function(e){if(this.length++,this.head){const t=this.head;this.head=se(null,t,e),t.previous=this.head}else this.tail=se(null,null,e),this.head=this.tail;return this.head},ke.prototype.remove=function(e){null!==e&&(e.previous?(e.previous.next=e.next,e.next?e.next.previous=e.previous:this.tail=e.previous,this.length--):e.next?(this.head=e.next,this.head.previous=null,this.length--):(this.head=null,this.tail=null,this.length=0),e=null)},ke.prototype.pop=function(){if(this.tail){const e=this.tail.element;return this.remove(this.tail),e}},ke.prototype.shift=function(){if(this.head){const e=this.head.element;return this.remove(this.head),e}},ke.prototype.forEach=function(e,t=!1){let r,n,o,i;for(this.shouldNextForEachBreak=!1,t?(o=this.length-1,r=this.tail,n="previous",i=function(){o--}):(o=0,r=this.head,n="next",i=function(){o++});r&&!this.shouldNextForEachBreak;){const t=r.element;if(!1===e.call(this,o,t))break;r=r[n],i()}},ke.prototype.break=function(){this.shouldNextForEachBreak=!0};const Ae={[te.SINGLE]:{ImmutableLinkedOrderedMapClass:class extends ye{constructor(e){const t=super(e);return t.mutationOperationOccurred=!1,t}set(e,t=!1){this.mutationOperationOccurred&&ve("set");const r=super.set(e,t);return this!==r&&(this.mutationOperationOccurred=!0),r}replace(e,t,r=!1,n=!1){this.mutationOperationOccurred&&ve("replace");const o=super.replace(e,t,r,n);return this!==o&&(this.mutationOperationOccurred=!0),o}unset(e){this.mutationOperationOccurred&&ve("unset");const t=super.unset(e);return this!==t&&(this.mutationOperationOccurred=!0),t}empty(){this.mutationOperationOccurred&&ve("empty");const e=super.empty();return this!==e&&(this.mutationOperationOccurred=!0),e}},lookup:function(e,t){const{heapMap:r,depth:n}=e;if(!r[t])return;let o;return r[t].forEach((e,t)=>{if(n>=e)return o=t,!1}),ce(o)},updateHeapMap:function(e,t){const{heapMap:r,depth:n}=e,o=t.element.key;r[o]||(r[o]=new Oe),r[o].set(n,t,!0)},findMapNodeByDirection:function(e,t,r){if(t===e.tail&&"next"===r||t===e.head&&"previous"===r)return null;const{depth:n}=e,o=t[r];let i=null;return o.forEach((e,t)=>{if(n>=e)return i=t,!1}),i},makeImmutableLinkedOrderedMapNode:function(e,t,r,n,o){const{depth:i}=e,s=new Oe;s.set(i,t);const u=new Oe;return u.set(i,r),se(s,u,{key:n,value:o})},bindNodes:function(e,t,r){const{depth:n}=e;t.next.set(n,r,!0),r.previous.set(n,t,!0)}},[te.MULTIWAY]:{ImmutableLinkedOrderedMapClass:class extends ye{constructor(e){const t=super(e);return t.childrenCount=0,t}},hydrate:function({version:e=""}={}){this.version=e},lookup:function(e,t){const{heapMap:r,depth:n,version:o}=e;if(!r[t])return;const i=r[t];let s=void 0;return i.forEach((e,t)=>{if(n>=e&&(t.forEach((e,t)=>{if(ge(e,o))return s=t,!1}),s))return!1}),ce(s)},fork:function(e,t){return t.version=e.version.length?`${e.version}${++e.childrenCount}#`:++e.childrenCount+"#",t},updateHeapMap:function(e,t){const{heapMap:r,depth:n,version:o}=e,i=t.element.key;r[i]||(r[i]=new Oe),r[i].map[n]||r[i].set(n,new Oe,!0),r[i].get(n).set(o,t,!0)},findMapNodeByDirection:function(e,t,r){if(t===e.tail&&"next"===r||t===e.head&&"previous"===r)return null;const{depth:n,version:o}=e,i=t[r];let s=null;return i.forEach((e,t)=>{if(n>=e&&(t.forEach((e,t)=>{if(ge(e,o))return s=t,!1}),s))return!1}),s},makeImmutableLinkedOrderedMapNode:function(e,t,r,n,o){const{depth:i,version:s}=e,u=new Oe,a=new Oe;a.set(s,t),u.set(i,a);const c=new Oe,l=new Oe;return l.set(s,r),c.set(i,l),se(u,c,{key:n,value:o})},bindNodes:function(e,t,r){const{depth:n,version:o}=e;t.next.map[n]||t.next.set(n,new Oe,!0),t.next.get(n).set(o,r,!0),r.previous.map[n]||r.previous.set(n,new Oe,!0),r.previous.get(n).set(o,t,!0)}},[te.LIGHTWEIGHT]:{ImmutableLinkedOrderedMapClass:class extends ye{constructor(e){const t=super(e);return t.mutationOperationOccurred=!1,t}set(e,t=!1){this.mutationOperationOccurred&&be("set");const r=super.set(e,t);return this!==r&&(this.mutationOperationOccurred=!0),r}replace(e,t,r=!1,n=!1){this.mutationOperationOccurred&&be("replace");const o=super.replace(e,t,r,n);return this!==o&&(this.mutationOperationOccurred=!0),o}unset(e){this.mutationOperationOccurred&&be("unset");const t=super.unset(e);return this!==t&&(this.mutationOperationOccurred=!0),t}empty(){this.mutationOperationOccurred&&be("empty");const e=super.empty();return this!==e&&(this.mutationOperationOccurred=!0),e}get(e){return this.mutationOperationOccurred&&be("get"),super.get(e)}first(){return this.mutationOperationOccurred&&be("first"),super.first()}last(){return this.mutationOperationOccurred&&be("last"),super.last()}isEmpty(){return this.mutationOperationOccurred&&be("isEmpty"),super.isEmpty()}forEach(e,t=!1){return this.mutationOperationOccurred&&be("forEach"),super.forEach(e,t)}break(){return this.mutationOperationOccurred&&be("break"),super.break()}values(e=!1){return this.mutationOperationOccurred&&be("values"),super.values(e)}keys(e=!1){return this.mutationOperationOccurred&&be("keys"),super.keys(e)}keysValues(e=!1){return this.mutationOperationOccurred&&be("keysValues"),super.keysValues(e)}map(e,t=!1){return this.mutationOperationOccurred&&be("map"),super.map(e,t)}reduce(e,t,r=!1){return this.mutationOperationOccurred&&be("reduce"),super.reduce(e,t,r)}filter(e,t=!1){return this.mutationOperationOccurred&&be("filter"),super.filter(e,t)}every(e,t=!1){return this.mutationOperationOccurred&&be("every"),super.every(e,t)}some(e,t=!1){return this.mutationOperationOccurred&&be("some"),super.some(e,t)}},lookup:function(e,t){const{heapMap:r}=e;return ce(r[t])},updateHeapMap:function(e,t){const{heapMap:r}=e;r[t.element.key]=t},findMapNodeByDirection:function(e,t,r){return t[r]},makeImmutableLinkedOrderedMapNode:function(e,t,r,n,o){return se(t,r,{key:n,value:o})},bindNodes:function(e,t,r){t.next=r,r.previous=t}}};ye.MODE=te,ye.isMap=e=>!(!e||!0!==e[ee]);const we=(e={})=>new ye({...e}),Me=(e={})=>we({...e,lazy:!0});[["lazyMap",Me],["map",we]].map(([e,t])=>ye[e]=t)}]).default}));